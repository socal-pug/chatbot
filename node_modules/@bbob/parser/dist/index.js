(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.BbobParser = {}));
}(this, (function (exports) { 'use strict';

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var char_1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.BACKSLASH = exports.PLACEHOLDER_SPACE = exports.PLACEHOLDER_SPACE_TAB = exports.SLASH = exports.CLOSE_BRAKET = exports.OPEN_BRAKET = exports.SPACE = exports.QUOTEMARK = exports.EQ = exports.TAB = exports.R = exports.F = exports.N = void 0;
	var N = '\n';
	exports.N = N;
	var TAB = '\t';
	exports.TAB = TAB;
	var F = '\f';
	exports.F = F;
	var R = '\r';
	exports.R = R;
	var EQ = '=';
	exports.EQ = EQ;
	var QUOTEMARK = '"';
	exports.QUOTEMARK = QUOTEMARK;
	var SPACE = ' ';
	exports.SPACE = SPACE;
	var OPEN_BRAKET = '[';
	exports.OPEN_BRAKET = OPEN_BRAKET;
	var CLOSE_BRAKET = ']';
	exports.CLOSE_BRAKET = CLOSE_BRAKET;
	var SLASH = '/';
	exports.SLASH = SLASH;
	var BACKSLASH = '\\';
	exports.BACKSLASH = BACKSLASH;
	var PLACEHOLDER_SPACE_TAB = '    ';
	exports.PLACEHOLDER_SPACE_TAB = PLACEHOLDER_SPACE_TAB;
	var PLACEHOLDER_SPACE = ' '; // const getChar = String.fromCharCode;

	exports.PLACEHOLDER_SPACE = PLACEHOLDER_SPACE;
	});

	unwrapExports(char_1);
	var char_2 = char_1.BACKSLASH;
	var char_3 = char_1.PLACEHOLDER_SPACE;
	var char_4 = char_1.PLACEHOLDER_SPACE_TAB;
	var char_5 = char_1.SLASH;
	var char_6 = char_1.CLOSE_BRAKET;
	var char_7 = char_1.OPEN_BRAKET;
	var char_8 = char_1.SPACE;
	var char_9 = char_1.QUOTEMARK;
	var char_10 = char_1.EQ;
	var char_11 = char_1.TAB;
	var char_12 = char_1.R;
	var char_13 = char_1.F;
	var char_14 = char_1.N;

	var lib = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.isEOL = exports.isStringNode = exports.isTagNode = exports.getUniqAttr = exports.getNodeLength = exports.appendToNode = exports.attrValue = exports.attrsToString = void 0;



	var isTagNode = function isTagNode(el) {
	  return typeof el === 'object' && !!el.tag;
	};

	exports.isTagNode = isTagNode;

	var isStringNode = function isStringNode(el) {
	  return typeof el === 'string';
	};

	exports.isStringNode = isStringNode;

	var isEOL = function isEOL(el) {
	  return el === char_1.N;
	};

	exports.isEOL = isEOL;

	var getNodeLength = function getNodeLength(node) {
	  if (isTagNode(node)) {
	    return node.content.reduce(function (count, contentNode) {
	      return count + getNodeLength(contentNode);
	    }, 0);
	  }

	  if (isStringNode(node)) {
	    return node.length;
	  }

	  return 0;
	};
	/**
	 * Appends value to Tag Node
	 * @param {TagNode} node
	 * @param value
	 */


	exports.getNodeLength = getNodeLength;

	var appendToNode = function appendToNode(node, value) {
	  node.content.push(value);
	};
	/**
	 * Replaces " to &qquot;
	 * @param {String} value
	 */


	exports.appendToNode = appendToNode;

	var escapeQuote = function escapeQuote(value) {
	  return value.replace(/"/g, '&quot;');
	};
	/**
	 * Acept name and value and return valid html5 attribute string
	 * @param {String} name
	 * @param {String} value
	 * @return {string}
	 */


	var attrValue = function attrValue(name, value) {
	  var type = typeof value;
	  var types = {
	    "boolean": function boolean() {
	      return value ? "" + name : '';
	    },
	    number: function number() {
	      return name + "=\"" + value + "\"";
	    },
	    string: function string() {
	      return name + "=\"" + escapeQuote(value) + "\"";
	    },
	    object: function object() {
	      return name + "=\"" + escapeQuote(JSON.stringify(value)) + "\"";
	    }
	  };
	  return types[type] ? types[type]() : '';
	};
	/**
	 * Transforms attrs to html params string
	 * @param values
	 */


	exports.attrValue = attrValue;

	var attrsToString = function attrsToString(values) {
	  // To avoid some malformed attributes
	  if (typeof values === 'undefined') {
	    return '';
	  }

	  return Object.keys(values).reduce(function (arr, key) {
	    return [].concat(arr, [attrValue(key, values[key])]);
	  }, ['']).join(' ');
	};
	/**
	 * Gets value from
	 * @example
	 * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'
	 * @param attrs
	 * @returns {string}
	 */


	exports.attrsToString = attrsToString;

	var getUniqAttr = function getUniqAttr(attrs) {
	  return Object.keys(attrs).reduce(function (res, key) {
	    return attrs[key] === key ? attrs[key] : null;
	  }, null);
	};

	exports.getUniqAttr = getUniqAttr;
	});

	unwrapExports(lib);
	var lib_1 = lib.isEOL;
	var lib_2 = lib.isStringNode;
	var lib_3 = lib.isTagNode;
	var lib_4 = lib.getUniqAttr;
	var lib_5 = lib.getNodeLength;
	var lib_6 = lib.appendToNode;
	var lib_7 = lib.attrValue;
	var lib_8 = lib.attrsToString;

	var TagNode_1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports["default"] = exports.TagNode = void 0;





	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	var getTagAttrs = function getTagAttrs(tag, params) {
	  var uniqAattr = (0, lib.getUniqAttr)(params);

	  if (uniqAattr) {
	    var tagAttr = (0, lib.attrValue)(tag, uniqAattr);

	    var attrs = _extends({}, params);

	    delete attrs[uniqAattr];
	    var attrsStr = (0, lib.attrsToString)(attrs);
	    return "" + tagAttr + attrsStr;
	  }

	  return "" + tag + (0, lib.attrsToString)(params);
	};

	var TagNode =
	/*#__PURE__*/
	function () {
	  function TagNode(tag, attrs, content) {
	    this.tag = tag;
	    this.attrs = attrs;
	    this.content = [].concat(content);
	  }

	  var _proto = TagNode.prototype;

	  _proto.attr = function attr(name, value) {
	    if (typeof value !== 'undefined') {
	      this.attrs[name] = value;
	    }

	    return this.attrs[name];
	  };

	  _proto.append = function append(value) {
	    return (0, lib.appendToNode)(this, value);
	  };

	  _proto.toTagNode = function toTagNode() {
	    return new TagNode(this.tag.toLowerCase(), this.attrs, this.content);
	  };

	  _proto.toString = function toString() {
	    var OB = char_1.OPEN_BRAKET;
	    var CB = char_1.CLOSE_BRAKET;
	    var isEmpty = this.content.length === 0;
	    var content = this.content.reduce(function (r, node) {
	      return r + node.toString();
	    }, '');
	    var tagAttrs = getTagAttrs(this.tag, this.attrs);

	    if (isEmpty) {
	      return "" + OB + tagAttrs + CB;
	    }

	    return "" + OB + tagAttrs + CB + content + OB + char_1.SLASH + this.tag + CB;
	  };

	  _createClass(TagNode, [{
	    key: "length",
	    get: function get() {
	      return (0, lib.getNodeLength)(this);
	    }
	  }]);

	  return TagNode;
	}();

	exports.TagNode = TagNode;

	TagNode.create = function (tag, attrs, content) {
	  if (attrs === void 0) {
	    attrs = {};
	  }

	  if (content === void 0) {
	    content = [];
	  }

	  return new TagNode(tag, attrs, content);
	};

	TagNode.isOf = function (node, type) {
	  return node.tag === type;
	};

	var _default = TagNode;
	exports["default"] = _default;
	});

	var TagNode = unwrapExports(TagNode_1);
	var TagNode_2 = TagNode_1.TagNode;

	var char_1$1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.BACKSLASH = exports.PLACEHOLDER_SPACE = exports.PLACEHOLDER_SPACE_TAB = exports.SLASH = exports.CLOSE_BRAKET = exports.OPEN_BRAKET = exports.SPACE = exports.QUOTEMARK = exports.EQ = exports.TAB = exports.R = exports.F = exports.N = void 0;
	var N = '\n';
	exports.N = N;
	var TAB = '\t';
	exports.TAB = TAB;
	var F = '\f';
	exports.F = F;
	var R = '\r';
	exports.R = R;
	var EQ = '=';
	exports.EQ = EQ;
	var QUOTEMARK = '"';
	exports.QUOTEMARK = QUOTEMARK;
	var SPACE = ' ';
	exports.SPACE = SPACE;
	var OPEN_BRAKET = '[';
	exports.OPEN_BRAKET = OPEN_BRAKET;
	var CLOSE_BRAKET = ']';
	exports.CLOSE_BRAKET = CLOSE_BRAKET;
	var SLASH = '/';
	exports.SLASH = SLASH;
	var BACKSLASH = '\\';
	exports.BACKSLASH = BACKSLASH;
	var PLACEHOLDER_SPACE_TAB = '    ';
	exports.PLACEHOLDER_SPACE_TAB = PLACEHOLDER_SPACE_TAB;
	var PLACEHOLDER_SPACE = ' '; // const getChar = String.fromCharCode;

	exports.PLACEHOLDER_SPACE = PLACEHOLDER_SPACE;
	});

	unwrapExports(char_1$1);
	var char_2$1 = char_1$1.BACKSLASH;
	var char_3$1 = char_1$1.PLACEHOLDER_SPACE;
	var char_4$1 = char_1$1.PLACEHOLDER_SPACE_TAB;
	var char_5$1 = char_1$1.SLASH;
	var char_6$1 = char_1$1.CLOSE_BRAKET;
	var char_7$1 = char_1$1.OPEN_BRAKET;
	var char_8$1 = char_1$1.SPACE;
	var char_9$1 = char_1$1.QUOTEMARK;
	var char_10$1 = char_1$1.EQ;
	var char_11$1 = char_1$1.TAB;
	var char_12$1 = char_1$1.R;
	var char_13$1 = char_1$1.F;
	var char_14$1 = char_1$1.N;

	var es = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.isEOL = exports.isStringNode = exports.isTagNode = exports.getUniqAttr = exports.getNodeLength = exports.appendToNode = exports.attrValue = exports.attrsToString = void 0;



	var isTagNode = function isTagNode(el) {
	  return typeof el === 'object' && !!el.tag;
	};

	exports.isTagNode = isTagNode;

	var isStringNode = function isStringNode(el) {
	  return typeof el === 'string';
	};

	exports.isStringNode = isStringNode;

	var isEOL = function isEOL(el) {
	  return el === char_1$1.N;
	};

	exports.isEOL = isEOL;

	var getNodeLength = function getNodeLength(node) {
	  if (isTagNode(node)) {
	    return node.content.reduce(function (count, contentNode) {
	      return count + getNodeLength(contentNode);
	    }, 0);
	  }

	  if (isStringNode(node)) {
	    return node.length;
	  }

	  return 0;
	};
	/**
	 * Appends value to Tag Node
	 * @param {TagNode} node
	 * @param value
	 */


	exports.getNodeLength = getNodeLength;

	var appendToNode = function appendToNode(node, value) {
	  node.content.push(value);
	};
	/**
	 * Replaces " to &qquot;
	 * @param {String} value
	 */


	exports.appendToNode = appendToNode;

	var escapeQuote = function escapeQuote(value) {
	  return value.replace(/"/g, '&quot;');
	};
	/**
	 * Acept name and value and return valid html5 attribute string
	 * @param {String} name
	 * @param {String} value
	 * @return {string}
	 */


	var attrValue = function attrValue(name, value) {
	  var type = typeof value;
	  var types = {
	    boolean: function boolean() {
	      return value ? "" + name : '';
	    },
	    number: function number() {
	      return name + "=\"" + value + "\"";
	    },
	    string: function string() {
	      return name + "=\"" + escapeQuote(value) + "\"";
	    },
	    object: function object() {
	      return name + "=\"" + escapeQuote(JSON.stringify(value)) + "\"";
	    }
	  };
	  return types[type] ? types[type]() : '';
	};
	/**
	 * Transforms attrs to html params string
	 * @param values
	 */


	exports.attrValue = attrValue;

	var attrsToString = function attrsToString(values) {
	  // To avoid some malformed attributes
	  if (typeof values === 'undefined') {
	    return '';
	  }

	  return Object.keys(values).reduce(function (arr, key) {
	    return [].concat(arr, [attrValue(key, values[key])]);
	  }, ['']).join(' ');
	};
	/**
	 * Gets value from
	 * @example
	 * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'
	 * @param attrs
	 * @returns {string}
	 */


	exports.attrsToString = attrsToString;

	var getUniqAttr = function getUniqAttr(attrs) {
	  return Object.keys(attrs).reduce(function (res, key) {
	    return attrs[key] === key ? attrs[key] : null;
	  }, null);
	};

	exports.getUniqAttr = getUniqAttr;
	});

	unwrapExports(es);
	var es_1 = es.isEOL;
	var es_2 = es.isStringNode;
	var es_3 = es.isTagNode;
	var es_4 = es.getUniqAttr;
	var es_5 = es.getNodeLength;
	var es_6 = es.appendToNode;
	var es_7 = es.attrValue;
	var es_8 = es.attrsToString;

	var TOKEN_TYPE_ID = 'type'; // 0;

	var TOKEN_VALUE_ID = 'value'; // 1;

	var TOKEN_COLUMN_ID = 'row'; // 2;

	var TOKEN_LINE_ID = 'line'; // 3;

	var TOKEN_TYPE_WORD = 'word';
	var TOKEN_TYPE_TAG = 'tag';
	var TOKEN_TYPE_ATTR_NAME = 'attr-name';
	var TOKEN_TYPE_ATTR_VALUE = 'attr-value';
	var TOKEN_TYPE_SPACE = 'space';
	var TOKEN_TYPE_NEW_LINE = 'new-line';
	/**
	 * @param {Token} token
	 * @returns {string}
	 */

	var getTokenValue = function getTokenValue(token) {
	  if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {
	    return token[TOKEN_VALUE_ID];
	  }

	  return '';
	};
	/**
	 * @param {Token}token
	 * @returns {number}
	 */


	var getTokenLine = function getTokenLine(token) {
	  return token && token[TOKEN_LINE_ID] || 0;
	};

	var getTokenColumn = function getTokenColumn(token) {
	  return token && token[TOKEN_COLUMN_ID] || 0;
	};
	/**
	 * @param {Token} token
	 * @returns {boolean}
	 */


	var isTextToken = function isTextToken(token) {
	  if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {
	    return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;
	  }

	  return false;
	};
	/**
	 * @param {Token} token
	 * @returns {boolean}
	 */


	var isTagToken = function isTagToken(token) {
	  if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {
	    return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;
	  }

	  return false;
	};

	var isTagEnd = function isTagEnd(token) {
	  return getTokenValue(token).charCodeAt(0) === char_5.charCodeAt(0);
	};

	var isTagStart = function isTagStart(token) {
	  return !isTagEnd(token);
	};

	var isAttrNameToken = function isAttrNameToken(token) {
	  if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {
	    return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;
	  }

	  return false;
	};
	/**
	 * @param {Token} token
	 * @returns {boolean}
	 */


	var isAttrValueToken = function isAttrValueToken(token) {
	  if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {
	    return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;
	  }

	  return false;
	};

	var getTagName = function getTagName(token) {
	  var value = getTokenValue(token);
	  return isTagEnd(token) ? value.slice(1) : value;
	};

	var convertTagToText = function convertTagToText(token) {
	  var text = char_7;
	  text += getTokenValue(token);
	  text += char_6;
	  return text;
	};

	var Token =
	/*#__PURE__*/
	function () {
	  /**
	   * @param {String} type
	   * @param {String} value
	   * @param line
	   * @param row
	   */
	  function Token(type, value, line, row) {
	    this[TOKEN_TYPE_ID] = String(type);
	    this[TOKEN_VALUE_ID] = String(value);
	    this[TOKEN_LINE_ID] = Number(line);
	    this[TOKEN_COLUMN_ID] = Number(row);
	  }

	  var _proto = Token.prototype;

	  _proto.isEmpty = function isEmpty() {
	    return !!this[TOKEN_TYPE_ID];
	  };

	  _proto.isText = function isText() {
	    return isTextToken(this);
	  };

	  _proto.isTag = function isTag() {
	    return isTagToken(this);
	  };

	  _proto.isAttrName = function isAttrName() {
	    return isAttrNameToken(this);
	  };

	  _proto.isAttrValue = function isAttrValue() {
	    return isAttrValueToken(this);
	  };

	  _proto.isStart = function isStart() {
	    return isTagStart(this);
	  };

	  _proto.isEnd = function isEnd() {
	    return isTagEnd(this);
	  };

	  _proto.getName = function getName() {
	    return getTagName(this);
	  };

	  _proto.getValue = function getValue() {
	    return getTokenValue(this);
	  };

	  _proto.getLine = function getLine() {
	    return getTokenLine(this);
	  };

	  _proto.getColumn = function getColumn() {
	    return getTokenColumn(this);
	  };

	  _proto.toString = function toString() {
	    return convertTagToText(this);
	  };

	  return Token;
	}();
	var TYPE_WORD = TOKEN_TYPE_WORD;
	var TYPE_TAG = TOKEN_TYPE_TAG;
	var TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;
	var TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;
	var TYPE_SPACE = TOKEN_TYPE_SPACE;
	var TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;

	/**
	 * @typedef {Object} CharGrabber
	 * @property {Function} skip
	 * @property {Function} hasNext
	 * @property {Function} isLast
	 * @property {Function} grabWhile
	 */

	/**
	 * Creates a grabber wrapper for source string, that helps to iterate over string char by char
	 * @param {String} source
	 * @param {Object} options
	 * @param {Function} options.onSkip
	 * @returns
	 */

	var createCharGrabber = function createCharGrabber(source, options) {
	  // let idx = 0;
	  var cursor = {
	    pos: 0,
	    length: source.length
	  };

	  var skip = function skip() {
	    cursor.pos += 1;

	    if (options && options.onSkip) {
	      options.onSkip();
	    }
	  };

	  var hasNext = function hasNext() {
	    return cursor.length > cursor.pos;
	  };

	  var getRest = function getRest() {
	    return source.substr(cursor.pos);
	  };

	  var getCurr = function getCurr() {
	    return source[cursor.pos];
	  };

	  return {
	    skip: skip,
	    hasNext: hasNext,
	    isLast: function isLast() {
	      return cursor.pos === cursor.length;
	    },

	    /**
	     * @param {Function} cond
	     * @returns {string}
	     */
	    grabWhile: function grabWhile(cond) {
	      var start = 0;

	      if (hasNext()) {
	        start = cursor.pos;

	        while (hasNext() && cond(getCurr())) {
	          skip();
	        }
	      }

	      return source.substr(start, cursor.pos - start);
	    },
	    getNext: function getNext() {
	      var nextPos = cursor.pos + 1;

	      if (nextPos <= source.length - 1) {
	        return source[nextPos];
	      }

	      return null;
	    },
	    getPrev: function getPrev() {
	      var prevPos = cursor.pos - 1;

	      if (typeof source[prevPos] !== 'undefined') {
	        return source[prevPos];
	      }

	      return null;
	    },
	    getCurr: getCurr,
	    getRest: getRest,

	    /**
	     * Grabs rest of string until it find a char
	     * @param {String} char
	     * @return {String}
	     */
	    substrUntilChar: function substrUntilChar(char) {
	      var restStr = getRest();
	      var indexOfChar = restStr.indexOf(char);

	      if (indexOfChar >= 0) {
	        return restStr.substr(0, indexOfChar);
	      }

	      return '';
	    }
	  };
	};
	/**
	 * Trims string from start and end by char
	 * @example
	 *  trimChar('*hello*', '*') ==> 'hello'
	 * @param {String} str
	 * @param {String} charToRemove
	 * @returns {String}
	 */

	var trimChar = function trimChar(str, charToRemove) {
	  while (str.charAt(0) === charToRemove) {
	    // eslint-disable-next-line no-param-reassign
	    str = str.substring(1);
	  }

	  while (str.charAt(str.length - 1) === charToRemove) {
	    // eslint-disable-next-line no-param-reassign
	    str = str.substring(0, str.length - 1);
	  }

	  return str;
	};
	/**
	 * Unquotes \" to "
	 * @param str
	 * @return {String}
	 */

	var unquote = function unquote(str) {
	  return str.replace(char_2 + char_9, char_9);
	};
	/**
	 * @typedef {Object} ItemList
	 * @type {Object}
	 * @property {getLastCb} getLast
	 * @property {flushLastCb} flushLast
	 * @property {pushCb} push
	 * @property {toArrayCb} toArray
	 */

	/**
	 *
	 * @param values
	 * @return {ItemList}
	 */

	var createList = function createList(values) {
	  if (values === void 0) {
	    values = [];
	  }

	  var nodes = values;
	  /**
	   * @callback getLastCb
	   */

	  var getLast = function getLast() {
	    if (Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined') {
	      return nodes[nodes.length - 1];
	    }

	    return null;
	  };
	  /**
	   * @callback flushLastCb
	   * @return {*}
	   */


	  var flushLast = function flushLast() {
	    if (nodes.length) {
	      return nodes.pop();
	    }

	    return false;
	  };
	  /**
	   * @callback pushCb
	   * @param value
	   */


	  var push = function push(value) {
	    return nodes.push(value);
	  };
	  /**
	   * @callback toArrayCb
	   * @return {Array}
	   */


	  return {
	    getLast: getLast,
	    flushLast: flushLast,
	    push: push,
	    toArray: function toArray() {
	      return nodes;
	    }
	  };
	};

	/* eslint-disable no-plusplus,no-param-reassign */

	var EM = '!';
	/**
	 * Creates a Token entity class
	 * @param {String} type
	 * @param {String} value
	 * @param {Number} r line number
	 * @param {Number} cl char number in line
	 */

	var createToken = function createToken(type, value, r, cl) {
	  if (r === void 0) {
	    r = 0;
	  }

	  if (cl === void 0) {
	    cl = 0;
	  }

	  return new Token(type, value, r, cl);
	};
	/**
	 * @typedef {Object} Lexer
	 * @property {Function} tokenize
	 * @property {Function} isTokenNested
	 */

	/**
	 * @param {String} buffer
	 * @param {Object} options
	 * @param {Function} options.onToken
	 * @param {String} options.openTag
	 * @param {String} options.closeTag
	 * @param {Boolean} options.enableEscapeTags
	 * @return {Lexer}
	 */


	function createLexer(buffer, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var row = 0;
	  var col = 0;
	  var tokenIndex = -1;
	  var tokens = new Array(Math.floor(buffer.length));
	  var openTag = options.openTag || char_7;
	  var closeTag = options.closeTag || char_6;
	  var escapeTags = options.enableEscapeTags;
	  var RESERVED_CHARS = [closeTag, openTag, char_9, char_2, char_8, char_11, char_10, char_14, EM];
	  var NOT_CHAR_TOKENS = [// ...(options.enableEscapeTags ? [BACKSLASH] : []),
	  openTag, char_8, char_11, char_14];
	  var WHITESPACES = [char_8, char_11];
	  var SPECIAL_CHARS = [char_10, char_8, char_11];

	  var isCharReserved = function isCharReserved(char) {
	    return RESERVED_CHARS.indexOf(char) >= 0;
	  };

	  var isWhiteSpace = function isWhiteSpace(char) {
	    return WHITESPACES.indexOf(char) >= 0;
	  };

	  var isCharToken = function isCharToken(char) {
	    return NOT_CHAR_TOKENS.indexOf(char) === -1;
	  };

	  var isSpecialChar = function isSpecialChar(char) {
	    return SPECIAL_CHARS.indexOf(char) >= 0;
	  };

	  var isEscapableChar = function isEscapableChar(char) {
	    return char === openTag || char === closeTag || char === char_2;
	  };

	  var isEscapeChar = function isEscapeChar(char) {
	    return char === char_2;
	  };
	  /**
	   * Emits newly created token to subscriber
	   * @param token
	   */


	  var emitToken = function emitToken(token) {
	    if (options.onToken) {
	      options.onToken(token);
	    }

	    tokenIndex += 1;
	    tokens[tokenIndex] = token;
	  };
	  /**
	   * Parses params inside [myTag---params goes here---]content[/myTag]
	   * @param str
	   * @returns {{tag: *, attrs: Array}}
	   */


	  var parseAttrs = function parseAttrs(str) {
	    var tagName = null;
	    var skipSpecialChars = false;
	    var attrTokens = [];
	    var attrCharGrabber = createCharGrabber(str);

	    var validAttr = function validAttr(char) {
	      var isEQ = char === char_10;
	      var isWS = isWhiteSpace(char);
	      var prevChar = attrCharGrabber.getPrev();
	      var nextChar = attrCharGrabber.getNext();
	      var isPrevSLASH = prevChar === char_2;
	      var isTagNameEmpty = tagName === null;

	      if (isTagNameEmpty) {
	        return (isEQ || isWS || attrCharGrabber.isLast()) === false;
	      }

	      if (skipSpecialChars && isSpecialChar(char)) {
	        return true;
	      }

	      if (char === char_9 && !isPrevSLASH) {
	        skipSpecialChars = !skipSpecialChars;

	        if (!skipSpecialChars && !(nextChar === char_10 || isWhiteSpace(nextChar))) {
	          return false;
	        }
	      }

	      return (isEQ || isWS) === false;
	    };

	    var nextAttr = function nextAttr() {
	      var attrStr = attrCharGrabber.grabWhile(validAttr);
	      var currChar = attrCharGrabber.getCurr(); // first string before space is a tag name [tagName params...]

	      if (tagName === null) {
	        tagName = attrStr;
	      } else if (isWhiteSpace(currChar) || currChar === char_9 || !attrCharGrabber.hasNext()) {
	        var escaped = unquote(trimChar(attrStr, char_9));
	        attrTokens.push(createToken(TYPE_ATTR_VALUE, escaped, row, col));
	      } else {
	        attrTokens.push(createToken(TYPE_ATTR_NAME, attrStr, row, col));
	      }

	      attrCharGrabber.skip();
	    };

	    while (attrCharGrabber.hasNext()) {
	      nextAttr();
	    }

	    return {
	      tag: tagName,
	      attrs: attrTokens
	    };
	  };

	  var bufferGrabber = createCharGrabber(buffer, {
	    onSkip: function onSkip() {
	      col++;
	    }
	  });

	  var next = function next() {
	    var currChar = bufferGrabber.getCurr();
	    var nextChar = bufferGrabber.getNext();

	    if (currChar === char_14) {
	      bufferGrabber.skip();
	      col = 0;
	      row++;
	      emitToken(createToken(TYPE_NEW_LINE, currChar, row, col));
	    } else if (isWhiteSpace(currChar)) {
	      var str = bufferGrabber.grabWhile(isWhiteSpace);
	      emitToken(createToken(TYPE_SPACE, str, row, col));
	    } else if (escapeTags && isEscapeChar(currChar) && isEscapableChar(nextChar)) {
	      bufferGrabber.skip(); // skip the \ without emitting anything

	      bufferGrabber.skip(); // skip past the [, ] or \ as well

	      emitToken(createToken(TYPE_WORD, nextChar, row, col));
	    } else if (currChar === openTag) {
	      bufferGrabber.skip(); // skip openTag
	      // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'

	      var substr = bufferGrabber.substrUntilChar(closeTag);
	      var hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;

	      if (isCharReserved(nextChar) || hasInvalidChars || bufferGrabber.isLast()) {
	        emitToken(createToken(TYPE_WORD, currChar, row, col));
	      } else {
	        var _str = bufferGrabber.grabWhile(function (val) {
	          return val !== closeTag;
	        });

	        bufferGrabber.skip(); // skip closeTag
	        // [myTag   ]

	        var isNoAttrsInTag = _str.indexOf(char_10) === -1; // [/myTag]

	        var isClosingTag = _str[0] === char_5;

	        if (isNoAttrsInTag || isClosingTag) {
	          emitToken(createToken(TYPE_TAG, _str, row, col));
	        } else {
	          var parsed = parseAttrs(_str);
	          emitToken(createToken(TYPE_TAG, parsed.tag, row, col));
	          parsed.attrs.map(emitToken);
	        }
	      }
	    } else if (currChar === closeTag) {
	      bufferGrabber.skip(); // skip closeTag

	      emitToken(createToken(TYPE_WORD, currChar, row, col));
	    } else if (isCharToken(currChar)) {
	      if (escapeTags && isEscapeChar(currChar) && !isEscapableChar(nextChar)) {
	        bufferGrabber.skip();
	        emitToken(createToken(TYPE_WORD, currChar, row, col));
	      } else {
	        var _str2 = bufferGrabber.grabWhile(function (char) {
	          if (escapeTags) {
	            return isCharToken(char) && !isEscapeChar(char);
	          }

	          return isCharToken(char);
	        });

	        emitToken(createToken(TYPE_WORD, _str2, row, col));
	      }
	    }
	  };

	  var tokenize = function tokenize() {
	    while (bufferGrabber.hasNext()) {
	      next();
	    }

	    tokens.length = tokenIndex + 1;
	    return tokens;
	  };

	  var isTokenNested = function isTokenNested(token) {
	    var value = openTag + char_5 + token.getValue(); // potential bottleneck

	    return buffer.indexOf(value) > -1;
	  };

	  return {
	    tokenize: tokenize,
	    isTokenNested: isTokenNested
	  };
	}

	/**
	 * @public
	 * @param {String} input
	 * @param {Object} opts
	 * @param {Function} opts.createTokenizer
	 * @param {Array<string>} opts.onlyAllowTags
	 * @param {String} opts.openTag
	 * @param {String} opts.closeTag
	 * @param {Boolean} opts.enableEscapeTags
	 * @return {Array}
	 */

	var parse = function parse(input, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var options = opts;
	  var tokenizer = null;
	  /**
	   * Result AST of nodes
	   * @private
	   * @type {ItemList}
	   */

	  var nodes = createList();
	  /**
	   * Temp buffer of nodes that's nested to another node
	   * @private
	   * @type {ItemList}
	   */

	  var nestedNodes = createList();
	  /**
	   * Temp buffer of nodes [tag..]...[/tag]
	   * @private
	   * @type {ItemList}
	   */

	  var tagNodes = createList();
	  /**
	   * Temp buffer of tag attributes
	   * @private
	   * @type {ItemList}
	   */

	  var tagNodesAttrName = createList();
	  /**
	   * Cache for nested tags checks
	   * @type {{}}
	   */

	  var nestedTagsMap = {};

	  var isTokenNested = function isTokenNested(token) {
	    if (typeof nestedTagsMap[token.getValue()] === 'undefined') {
	      nestedTagsMap[token.getValue()] = tokenizer.isTokenNested(token);
	    }

	    return nestedTagsMap[token.getValue()];
	  };
	  /**
	   * @param tagName
	   * @returns {boolean}
	   */


	  var isTagNested = function isTagNested(tagName) {
	    return !!nestedTagsMap[tagName];
	  };
	  /**
	   * @private
	   * @param {String} value
	   * @return {boolean}
	   */


	  var isAllowedTag = function isAllowedTag(value) {
	    if (options.onlyAllowTags && options.onlyAllowTags.length) {
	      return options.onlyAllowTags.indexOf(value) >= 0;
	    }

	    return true;
	  };
	  /**
	   * Flushes temp tag nodes and its attributes buffers
	   * @private
	   * @return {Array}
	   */


	  var flushTagNodes = function flushTagNodes() {
	    if (tagNodes.flushLast()) {
	      tagNodesAttrName.flushLast();
	    }
	  };
	  /**
	   * @private
	   * @return {Array}
	   */


	  var getNodes = function getNodes() {
	    var lastNestedNode = nestedNodes.getLast();

	    if (lastNestedNode && Array.isArray(lastNestedNode.content)) {
	      return lastNestedNode.content;
	    }

	    return nodes.toArray();
	  };
	  /**
	   * @private
	   * @param {string|TagNode} node
	   */


	  var appendNodes = function appendNodes(node) {
	    var items = getNodes();

	    if (Array.isArray(items)) {
	      if (es_3(node)) {
	        if (isAllowedTag(node.tag)) {
	          items.push(node.toTagNode());
	        } else {
	          items.push(node.toString());
	        }
	      } else {
	        items.push(node);
	      }
	    }
	  };
	  /**
	   * @private
	   * @param {Token} token
	   */


	  var handleTagStart = function handleTagStart(token) {
	    flushTagNodes();
	    var tagNode = TagNode.create(token.getValue());
	    var isNested = isTokenNested(token);
	    tagNodes.push(tagNode);

	    if (isNested) {
	      nestedNodes.push(tagNode);
	    } else {
	      appendNodes(tagNode);
	    }
	  };
	  /**
	   * @private
	   * @param {Token} token
	   */


	  var handleTagEnd = function handleTagEnd(token) {
	    flushTagNodes();
	    var lastNestedNode = nestedNodes.flushLast();

	    if (lastNestedNode) {
	      appendNodes(lastNestedNode);
	    } else if (typeof options.onError === 'function') {
	      var tag = token.getValue();
	      var line = token.getLine();
	      var column = token.getColumn();
	      options.onError({
	        message: "Inconsistent tag '" + tag + "' on line " + line + " and column " + column,
	        tagName: tag,
	        lineNumber: line,
	        columnNumber: column
	      });
	    }
	  };
	  /**
	   * @private
	   * @param {Token} token
	   */


	  var handleTag = function handleTag(token) {
	    // [tag]
	    if (token.isStart()) {
	      handleTagStart(token);
	    } // [/tag]


	    if (token.isEnd()) {
	      handleTagEnd(token);
	    }
	  };
	  /**
	   * @private
	   * @param {Token} token
	   */


	  var handleNode = function handleNode(token) {
	    /**
	     * @type {TagNode}
	     */
	    var lastTagNode = tagNodes.getLast();
	    var tokenValue = token.getValue();
	    var isNested = isTagNested(token);

	    if (lastTagNode) {
	      if (token.isAttrName()) {
	        tagNodesAttrName.push(tokenValue);
	        lastTagNode.attr(tagNodesAttrName.getLast(), '');
	      } else if (token.isAttrValue()) {
	        var attrName = tagNodesAttrName.getLast();

	        if (attrName) {
	          lastTagNode.attr(attrName, tokenValue);
	          tagNodesAttrName.flushLast();
	        } else {
	          lastTagNode.attr(tokenValue, tokenValue);
	        }
	      } else if (token.isText()) {
	        if (isNested) {
	          lastTagNode.append(tokenValue);
	        } else {
	          appendNodes(tokenValue);
	        }
	      } else if (token.isTag()) {
	        // if tag is not allowed, just past it as is
	        appendNodes(token.toString());
	      }
	    } else if (token.isText()) {
	      appendNodes(tokenValue);
	    } else if (token.isTag()) {
	      // if tag is not allowed, just past it as is
	      appendNodes(token.toString());
	    }
	  };
	  /**
	   * @private
	   * @param {Token} token
	   */


	  var onToken = function onToken(token) {
	    if (token.isTag()) {
	      handleTag(token);
	    } else {
	      handleNode(token);
	    }
	  };

	  tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {
	    onToken: onToken,
	    onlyAllowTags: options.onlyAllowTags,
	    openTag: options.openTag,
	    closeTag: options.closeTag,
	    enableEscapeTags: options.enableEscapeTags
	  }); // eslint-disable-next-line no-unused-vars

	  var tokens = tokenizer.tokenize();
	  return nodes.toArray();
	};

	exports.TagNode = TagNode_2;
	exports.default = parse;
	exports.parse = parse;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
