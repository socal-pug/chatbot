"use strict";

exports.__esModule = true;
exports.createLexer = createLexer;
exports.createTokenOfType = void 0;

var _char10 = require("@bbob/plugin-helper/lib/char");

var _Token = require("./Token");

var _utils = require("./utils");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// for cases <!-- -->
var EM = '!';
/**
 * Creates a Token entity class
 * @param {String} type
 * @param {String} value
 * @param {Number} r line number
 * @param {Number} cl char number in line
 */

var createToken = function createToken(type, value) {
  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var cl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return new _Token.Token(type, value, r, cl);
};
/**
 * @typedef {Object} Lexer
 * @property {Function} tokenize
 * @property {Function} isTokenNested
 */
// [tag attr-name="attr-value"]content[/tag] other content


var STATE_WORD = 0;
var STATE_TAG = 1;
var STATE_ATTR = 2;
var STATE_ATTR_NAME = 3;
var STATE_ATTR_VALUE = 4;
/**
 * @param {String} buffer
 * @param {Object} options
 * @param {Function} options.onToken
 * @param {String} options.openTag
 * @param {String} options.closeTag
 * @param {Boolean} options.enableEscapeTags
 * @return {Lexer}
 */

function createLexer(buffer) {
  var _modeMap;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var row = 0;
  var col = 0;
  var tokenIndex = -1;
  var mode = 0;
  var tokens = new Array(Math.floor(buffer.length));
  var openTag = options.openTag || _char10.OPEN_BRAKET;
  var closeTag = options.closeTag || _char10.CLOSE_BRAKET;
  var escapeTags = options.enableEscapeTags;
  var RESERVED_CHARS = [closeTag, openTag, _char10.QUOTEMARK, _char10.BACKSLASH, _char10.SPACE, _char10.TAB, _char10.EQ, _char10.N, EM];
  var NOT_CHAR_TOKENS = [// ...(options.enableEscapeTags ? [BACKSLASH] : []),
  openTag, _char10.SPACE, _char10.TAB, _char10.N];
  var WHITESPACES = [_char10.SPACE, _char10.TAB];
  var SPECIAL_CHARS = [_char10.EQ, _char10.SPACE, _char10.TAB];

  var isCharReserved = function isCharReserved(_char) {
    return RESERVED_CHARS.indexOf(_char) >= 0;
  };

  var isNewLine = function isNewLine(_char2) {
    return _char2 === _char10.N;
  };

  var isWhiteSpace = function isWhiteSpace(_char3) {
    return WHITESPACES.indexOf(_char3) >= 0;
  };

  var isCharToken = function isCharToken(_char4) {
    return NOT_CHAR_TOKENS.indexOf(_char4) === -1;
  };

  var isSpecialChar = function isSpecialChar(_char5) {
    return SPECIAL_CHARS.indexOf(_char5) >= 0;
  };

  var isEscapableChar = function isEscapableChar(_char6) {
    return _char6 === openTag || _char6 === closeTag || _char6 === _char10.BACKSLASH;
  };

  var isEscapeChar = function isEscapeChar(_char7) {
    return _char7 === _char10.BACKSLASH;
  };

  var bufferGrabber = (0, _utils.createCharGrabber)(buffer, {
    onSkip: function onSkip() {
      col++;
    }
  });
  /**
   * Emits newly created token to subscriber
   * @param token
   */

  var emitToken = function emitToken(token) {
    if (options.onToken) {
      options.onToken(token);
    }

    tokenIndex += 1;
    tokens[tokenIndex] = token;
  };

  var switchMode = function switchMode(newMode) {
    mode = newMode;
  };

  var processWord = function processWord() {
    var currChar = bufferGrabber.getCurr();
    var nextChar = bufferGrabber.getNext();

    if (currChar === openTag && bufferGrabber.includes(closeTag)) {
      return switchMode(STATE_TAG);
    }

    if (isNewLine(currChar)) {
      bufferGrabber.skip();
      col = 0;
      row++;
      return emitToken(createToken(_Token.TYPE_NEW_LINE, currChar, row, col));
    }

    if (isWhiteSpace(currChar)) {
      return emitToken(createToken(_Token.TYPE_SPACE, bufferGrabber.grabWhile(isWhiteSpace), row, col));
    }

    if (escapeTags) {
      if (isEscapeChar(currChar) && !isEscapableChar(nextChar)) {
        bufferGrabber.skip();
        return emitToken(createToken(_Token.TYPE_WORD, currChar, row, col));
      }

      var _str = bufferGrabber.grabWhile(function (_char8) {
        return isCharToken(_char8) && !isEscapeChar(_char8);
      });

      return emitToken(createToken(_Token.TYPE_WORD, _str, row, col));
    }

    var str = bufferGrabber.grabWhile(function (_char9) {
      return isCharToken(_char9);
    });
    return emitToken(createToken(_Token.TYPE_WORD, str, row, col));
  };

  var processTag = function processTag() {
    var currChar = bufferGrabber.getCurr();
    var nextChar = bufferGrabber.getNext();

    if (currChar === closeTag) {
      bufferGrabber.skip(); // skip closeTag

      switchMode(STATE_WORD);
      return emitToken(createToken(_Token.TYPE_WORD, currChar, row, col));
    }

    if (currChar === openTag) {
      bufferGrabber.skip(); // skip openTag
      // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'

      var str = bufferGrabber.grabWhile(function (val) {
        return val !== closeTag;
      });
      var hasInvalidChars = str.length === 0 || str.indexOf(openTag) >= 0;

      if (isCharReserved(nextChar) || hasInvalidChars || bufferGrabber.isLast()) {
        return emitToken(createToken(_Token.TYPE_WORD, currChar, row, col));
      }

      bufferGrabber.skip(); // skip closeTag
      // [myTag   ]

      var isNoAttrsInTag = str.indexOf(_char10.EQ) === -1; // [/myTag]

      var isClosingTag = str[0] === _char10.SLASH;

      if (isNoAttrsInTag || isClosingTag) {
        return emitToken(createToken(_Token.TYPE_TAG, str, row, col));
      }
    }

    return switchMode(STATE_WORD);
  };

  var processAttrName = function processAttrName() {};

  var processAttrValue = function processAttrValue() {};

  var modeMap = (_modeMap = {}, _defineProperty(_modeMap, STATE_WORD, processWord), _defineProperty(_modeMap, STATE_TAG, processTag), _defineProperty(_modeMap, STATE_ATTR_NAME, processAttrName), _defineProperty(_modeMap, STATE_ATTR_VALUE, processAttrValue), _modeMap);

  var tokenize = function tokenize() {
    while (bufferGrabber.hasNext()) {
      modeMap[mode](bufferGrabber);
    }

    tokens.length = tokenIndex + 1;
    return tokens;
  };

  var isTokenNested = function isTokenNested(token) {
    var value = openTag + _char10.SLASH + token.getValue(); // potential bottleneck

    return buffer.indexOf(value) > -1;
  };

  return {
    tokenize: tokenize,
    isTokenNested: isTokenNested
  };
}

var createTokenOfType = createToken;
exports.createTokenOfType = createTokenOfType;