"use strict";

exports.__esModule = true;
exports.createList = exports.unquote = exports.trimChar = exports.createCharGrabber = void 0;

var _char = require("@bbob/plugin-helper/lib/char");

/**
 * @typedef {Object} CharGrabber
 * @property {Function} skip
 * @property {Function} hasNext
 * @property {Function} isLast
 * @property {Function} grabWhile
 */

/**
 * Creates a grabber wrapper for source string, that helps to iterate over string char by char
 * @param {String} source
 * @param {Object} options
 * @param {Function} options.onSkip
 * @returns
 */
var createCharGrabber = (source, options) => {
  // let idx = 0;
  var cursor = {
    pos: 0,
    length: source.length
  };

  var skip = () => {
    cursor.pos += 1;

    if (options && options.onSkip) {
      options.onSkip();
    }
  };

  var hasNext = () => cursor.length > cursor.pos;

  var getRest = () => source.substr(cursor.pos);

  var getCurr = () => source[cursor.pos];

  return {
    skip,
    hasNext,
    isLast: () => cursor.pos === cursor.length,

    /**
     * @param {Function} cond
     * @returns {string}
     */
    grabWhile: cond => {
      var start = 0;

      if (hasNext()) {
        start = cursor.pos;

        while (hasNext() && cond(getCurr())) {
          skip();
        }
      }

      return source.substr(start, cursor.pos - start);
    },
    getNext: () => {
      var nextPos = cursor.pos + 1;

      if (nextPos <= source.length - 1) {
        return source[nextPos];
      }

      return null;
    },
    getPrev: () => {
      var prevPos = cursor.pos - 1;

      if (typeof source[prevPos] !== 'undefined') {
        return source[prevPos];
      }

      return null;
    },
    getCurr,
    getRest,

    /**
     * Grabs rest of string until it find a char
     * @param {String} char
     * @return {String}
     */
    substrUntilChar: char => {
      var restStr = getRest();
      var indexOfChar = restStr.indexOf(char);

      if (indexOfChar >= 0) {
        return restStr.substr(0, indexOfChar);
      }

      return '';
    }
  };
};
/**
 * Trims string from start and end by char
 * @example
 *  trimChar('*hello*', '*') ==> 'hello'
 * @param {String} str
 * @param {String} charToRemove
 * @returns {String}
 */


exports.createCharGrabber = createCharGrabber;

var trimChar = (str, charToRemove) => {
  while (str.charAt(0) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(1);
  }

  while (str.charAt(str.length - 1) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(0, str.length - 1);
  }

  return str;
};
/**
 * Unquotes \" to "
 * @param str
 * @return {String}
 */


exports.trimChar = trimChar;

var unquote = str => str.replace(_char.BACKSLASH + _char.QUOTEMARK, _char.QUOTEMARK);
/**
 * @typedef {Object} ItemList
 * @type {Object}
 * @property {getLastCb} getLast
 * @property {flushLastCb} flushLast
 * @property {pushCb} push
 * @property {toArrayCb} toArray
 */

/**
 *
 * @param values
 * @return {ItemList}
 */


exports.unquote = unquote;

var createList = function createList(values) {
  if (values === void 0) {
    values = [];
  }

  var nodes = values;
  /**
   * @callback getLastCb
   */

  var getLast = () => {
    if (Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined') {
      return nodes[nodes.length - 1];
    }

    return null;
  };
  /**
   * @callback flushLastCb
   * @return {*}
   */


  var flushLast = () => {
    if (nodes.length) {
      return nodes.pop();
    }

    return false;
  };
  /**
   * @callback pushCb
   * @param value
   */


  var push = value => nodes.push(value);
  /**
   * @callback toArrayCb
   * @return {Array}
   */


  return {
    getLast,
    flushLast,
    push,
    toArray: () => nodes
  };
};

exports.createList = createList;